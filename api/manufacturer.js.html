<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: manufacturer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: manufacturer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Puzzle = require('./puzzle');
const Piece = require('./piece');
const {Anchor} = require('./anchor');
const {anchor} = require('./anchor');
const {fixed, InsertSequence} = require('./sequence')
const Metadata = require('./metadata');

/**
 * A manufacturer allows to create rectangular
 * puzzles by automatically generating inserts
 */
class Manufacturer {
  constructor() {
    this.insertsGenerator = fixed;
    this.metadata = [];
    /** @type {Anchor} */
    this.headAnchor = null;
  }

  /**
   * Attach metadata to each piece
   *
   * @param {object[]} metadata list of metadata that will be attached to each generated piece
   */
  withMetadata(metadata) {
    this.metadata = metadata;
  }

  /**
   * @param {import('./sequence').InsertsGenerator} generator
   */
  withInsertsGenerator(generator) {
    this.insertsGenerator = generator || this.insertsGenerator;
  }

  /**
   * Sets the central anchor. If not specified, puzzle will be positioned
   * at the distance of a whole piece from the origin
   *
   * @param {Anchor} anchor
   */
  withHeadAt(anchor) {
    this.headAnchor = anchor;
  }

  /**
   * If nothing is configured, default Puzzle structured is assumed
   *
   * @param {import('../src/puzzle').Settings} structure
   */
  withStructure(structure) {
    this.structure = structure
  }

  /**
   *
   * @param {number} width
   * @param {number} height
   */
  withDimmensions(width, height) {
    this.width = width;
    this.height = height;
  }

   /**
   * @returns {Puzzle}
   */
  build() {
    const puzzle = new Puzzle(this.structure);
    const positioner = new Positioner(puzzle, this.headAnchor);

    let verticalSequence = this._newSequence();
    let horizontalSequence;

    for (let y = 0; y &lt; this.height; y++) {
      horizontalSequence = this._newSequence();
      verticalSequence.next();

      for (let x = 0; x &lt; this.width; x++) {
        horizontalSequence.next();
        const piece = this._buildPiece(puzzle, horizontalSequence, verticalSequence);
        piece.placeAt(positioner.naturalAnchor(x, y));
      }
    }
    this._annotateAll(puzzle.pieces);
    return puzzle;
  }

  /**
   * @param {Piece[]} pieces
   */
  _annotateAll(pieces) {
    pieces.forEach((piece, index) => this._annotate(piece, index));
  }

  /**
   * @param {Piece} piece
   * @param {number} index
   */
  _annotate(piece, index) {
    const baseMetadata = this.metadata[index];
    const metadata = baseMetadata ? Metadata.copy(baseMetadata) : {};
    metadata.id = metadata.id || String(index + 1);
    piece.annotate(metadata);
  }

  _newSequence() {
    return new InsertSequence(this.insertsGenerator);
  }

  /**
   * @param {Puzzle} puzzle
   * @param {InsertSequence} horizontalSequence
   * @param {InsertSequence} verticalSequence
   */
  _buildPiece(puzzle, horizontalSequence, verticalSequence) {
    return puzzle.newPiece({
      left: horizontalSequence.previousComplement(),
      up: verticalSequence.previousComplement(),
      right: horizontalSequence.current(this.width),
      down: verticalSequence.current(this.height)
    });
  }
}

class Positioner {
  constructor(puzzle, headAnchor) {
    this.puzzle = puzzle;
    this.initializeOffset(headAnchor);
  }

  initializeOffset(headAnchor) {
    if (headAnchor) {
      this.xOffset = headAnchor.x;
      this.yOffset = headAnchor.y;
    }
    else {
      this.xOffset = this.realSize;
      this.yOffset = this.realSize;
    }
  }

  get realSize() {
    return this.puzzle.pieceSize * 2;
  }

    /**
   * @param {number} x
   * @param {number} y
   */
  naturalAnchor(x, y) {
    return anchor(
      x * this.realSize + this.xOffset,
      y * this.realSize + this.yOffset);
  }
}

/**
 * @module Manufacturer
 */
module.exports = Manufacturer;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Anchor.html">Anchor</a></li><li><a href="module-Canvas.html">Canvas</a></li><li><a href="module-DummyPainter.html">DummyPainter</a></li><li><a href="module-ImageMetadata.html">ImageMetadata</a></li><li><a href="module-insert.html">insert</a></li><li><a href="module-KonvaPainter.html">KonvaPainter</a></li><li><a href="module-Manufacturer.html">Manufacturer</a></li><li><a href="module-Metadata.html">Metadata</a></li><li><a href="module-Outline.html">Outline</a></li><li><a href="module-Piece.html">Piece</a></li><li><a href="module-Puzzle.html">Puzzle</a></li><li><a href="module-sequence.html">sequence</a></li><li><a href="module-Structure.html">Structure</a></li><li><a href="module-Vector.html">Vector</a></li></ul><h3>Classes</h3><ul><li><a href="Anchor.html">Anchor</a></li><li><a href="Canvas.html">Canvas</a></li><li><a href="Connector.html">Connector</a></li><li><a href="DummyPainter.html">DummyPainter</a></li><li><a href="InsertSequence.html">InsertSequence</a></li><li><a href="KonvaPainter.html">KonvaPainter</a></li><li><a href="Manufacturer.html">Manufacturer</a></li><li><a href="Piece.html">Piece</a></li><li><a href="Puzzle.html">Puzzle</a></li></ul><h3>Interfaces</h3><ul><li><a href="Painter.html">Painter</a></li></ul><h3>Global</h3><ul><li><a href="global.html#anchor">anchor</a></li><li><a href="global.html#asImageMetadata">asImageMetadata</a></li><li><a href="global.html#asStructure">asStructure</a></li><li><a href="global.html#between">between</a></li><li><a href="global.html#copy">copy</a></li><li><a href="global.html#currentPositionDiff">currentPositionDiff</a></li><li><a href="global.html#deserialize">deserialize</a></li><li><a href="global.html#equal">equal</a></li><li><a href="global.html#fixed">fixed</a></li><li><a href="global.html#flipflop">flipflop</a></li><li><a href="global.html#itself">itself</a></li><li><a href="global.html#origin">origin</a></li><li><a href="global.html#orthogonalMap">orthogonalMap</a></li><li><a href="global.html#orthogonalTransform">orthogonalTransform</a></li><li><a href="global.html#parseInsert">parseInsert</a></li><li><a href="global.html#pivot">pivot</a></li><li><a href="global.html#position">position</a></li><li><a href="global.html#random">random</a></li><li><a href="global.html#serialize">serialize</a></li><li><a href="global.html#setMetadataPositions">setMetadataPositions</a></li><li><a href="global.html#twoAndTwo">twoAndTwo</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Fri Jul 03 2020 21:50:18 GMT-0300 (-03)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
