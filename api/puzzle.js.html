<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: puzzle.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: puzzle.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const vector = require('./vector');
const pivot = require('./pivot');
const {Anchor} = require('./anchor');

/**
 * @typedef {{pieceSize?: number, proximity?: number}} PuzzleStructure
 */
class Puzzle {

  /**
   * @param {PuzzleStructure?} options
   */
  constructor({pieceSize = 2, proximity = 1} = {}) {
    this.pieceSize = pieceSize;
    this.proximity = proximity;
    /** @type {Piece[]} */
    this.pieces = [];
  }

  /**
   * @param {PieceStructure?} options
   */
  newPiece(options = {}) {
    const piece = new Piece(options);
    this.pieces.push(piece);
    piece.belongsTo(this);
    return piece;
  }

  /**
   * Tries to connect pieces in their current positions
   * This method is O(n^2)
   */
  autoconnectAll() {
    this.pieces.forEach(it => this.autoconnect(it));
  }

  disconnectAll() {
    this.pieces.forEach(it => it.disconnect());
  }

  /**
   * Tries to connect the given piece to the rest of the set
   * This method is O(n)
   * @param {Piece} piece
   */
  autoconnect(piece) {
    this.pieces.filter(it => it !== piece).forEach(other => {
      piece.tryConnectWith(other);
      other.tryConnectWith(piece, true);
    })
  }

  /**
   * @param {number} maxX
   * @param {number} maxY
   */
  shuffle(maxX, maxY) {
    this.disconnectAll();
    this.pieces.forEach(it => it.placeAt(Anchor.atRandom(maxX, maxY)));
    this.autoconnectAll();
  }

  /**
   * @param {number} dx
   * @param {number} dy
   */
  translate(dx, dy) {
    this.pieces.forEach(it => it.translate(dx, dy));
  }

    /**
   * @param {TranslationListener} f
   */
  onTranslate(f) {
    this.pieces.forEach(it => it.onTranslate(f));
  }

  /**
   * @param {ConnectListener} f
   */
  onConnect(f) {
    this.pieces.forEach(it => it.onConnect(f));
  }

  /**
   * @param {DisconnectListener} f
   */
  onDisconnect(f) {
    this.pieces.forEach(it => it.onDisconnect(f));
  }

  get data() {
    return this.pieces.map(it => it.data);
  }
}

/**
 * @typedef {function(number, number):void} TranslationListener
 * @typedef {function(Piece):void} ConnectListener
 * @typedef {function():void} DisconnectListener
 * @typedef {{up?: Insert, down?: Insert, left?: Insert, right?: Insert}} PieceStructure
 */
class Piece {

  /**
   * @param {PieceStructure?} options
   */
  constructor({up = None, down = None, left = None, right = None} = {}) {
    this.up = up;
    this.down = down;
    this.left = left;
    this.right = right;
    this._initializeListeners();
  }

  _initializeListeners() {
    /** @type {TranslationListener[]} */
    this.translateListeners = [];
    /** @type {ConnectListener[]} */
    this.connectListeners = [];
    /** @type {DisconnectListener[]} */
    this.disconnectListeners = [];
  }

  /**
   * @param {object} data
   */
  carry(data) {
    this.data = data;
  }

  /**
   * @param {Puzzle} puzzle
   */
  belongsTo(puzzle) {
    this.puzzle = puzzle;
  }

  /**
   * @returns {Piece[]}
   */
  get connections() {
    return [
      this.upConnection,
      this.downConnection,
      this.leftConnection,
      this.rightConnection
    ].filter(it => it);
  }

  /**
   * @param {TranslationListener} f
   */
  onTranslate(f) {
    this.translateListeners.push(f);
  }

  /**
   * @param {ConnectListener} f
   */
  onConnect(f) {
    this.connectListeners.push(f);
  }

  /**
   * @param {DisconnectListener} f
   */
  onDisconnect(f) {
    this.disconnectListeners.push(f);
  }

  /**
   * @param {number} dx
   * @param {number} dy
   */
  fireOnTranslate(dx, dy) {
    this.translateListeners.forEach(it => it(dx, dy))
  }

  /**
   * @param {Piece} other
   */
  fireOnConnect(other) {
    this.connectListeners.forEach(it => it(other))
  }

  fireOnDisconnect() {
    this.disconnectListeners.forEach(it => it())
  }

  /**
   *
   * @param {Piece} other
   * @param {boolean?} back
   */
  connectVerticallyWith(other, back = false) {
    if (!this.canConnectVerticallyWith(other)) {
      throw new Error("can not connect vertically!");
    }
    other.attractVertically(this, back);
    this.downConnection = other;
    other.upConnection = this;
    this.fireOnConnect(other);
  }

  /**
   * @param {Piece} other
   */
  attractVertically(other, back = false) {
    const [iron, magnet] = pivot(this, other, back);
    let dx, dy;
    if (magnet.centralAnchor.y > iron.centralAnchor.y) {
      [dx, dy] = magnet.upAnchor.diff(iron.downAnchor)
    } else {
      [dx, dy] = magnet.downAnchor.diff(iron.upAnchor)
    }
    iron.push(dx, dy);
  }

  /**
   * @param {Piece} other
   * @param {boolean?} back
   */
  connectHorizontallyWith(other, back = false) {
    if (!this.canConnectHorizontallyWith(other)) {
      throw new Error("can not connect horizontally!");
    }
    other.attractHorizontally(this, back);
    this.rightConnection = other;
    other.leftConnection = this;
    this.fireOnConnect(other);
  }

  /**
   * @param {Piece} other
   */
  attractHorizontally(other, back = false) {
    const [iron, magnet] = pivot(this, other, back);
    let dx, dy;
    if (magnet.centralAnchor.x > iron.centralAnchor.x) {
      [dx, dy] = magnet.leftAnchor.diff(iron.rightAnchor)
    } else {
      [dx, dy] = magnet.rightAnchor.diff(iron.leftAnchor)
    }
    iron.push(dx, dy);
  }

  /**
   * @param {Piece} other
   * @param {boolean?} back
   */
  tryConnectWith(other, back = false) {
    this.tryConnectHorizontallyWith(other, back);
    this.tryConnectVerticallyWith(other, back);
  }

  /**
   *
   * @param {Piece} other
   * @param {boolean?} back
   */
  tryConnectHorizontallyWith(other, back = false) {
    if (this.canConnectHorizontallyWith(other)) {
      this.connectHorizontallyWith(other, back);
    }
  }
  /**
   *
   * @param {Piece} other
   * @param {boolean?} back
   */
  tryConnectVerticallyWith(other, back = false) {
    if (this.canConnectVerticallyWith(other)) {
      this.connectVerticallyWith(other, back);
    }
  }

  disconnect() {
    if (this.connected) {
      this.fireOnDisconnect();
    }

    if (this.upConnection) {
      this.upConnection.downConnection = null;
      /** @type {Piece} */
      this.upConnection = null;
    }

    if (this.downConnection) {
      this.downConnection.upConnection = null;
      this.downConnection = null;
    }

    if (this.leftConnection) {
      this.leftConnection.rightConnection = null;
      /** @type {Piece} */
      this.leftConnection = null;
    }

    if (this.rightConnection) {
      this.rightConnection.leftConnection = null;
      this.rightConnection = null;
    }
  }

  /**
   *
   * @param {Anchor} anchor
   */
  placeAt(anchor) {
    const previous = this.centralAnchor;
    this.centralAnchor = anchor;

    if (previous) {
      const delta = anchor.diff(previous);
      this.fireOnTranslate(...delta);
    }
  }

  /**
   *
   * @param {number} dx
   * @param {number} dy
   */
  translate(dx, dy, quiet = false) {
    if (!vector.isNull(dx, dy)) {
      this.centralAnchor.translate(dx, dy);
      if (!quiet) {
        this.fireOnTranslate(dx, dy);
      }
    }
  }

  /**
   *
   * @param {number} dx
   * @param {number} dy
   * @param {boolean?} quiet
   * @param {Piece[]} pushedPieces
   */
  push(dx, dy, quiet = false, pushedPieces = [this]) {
    this.translate(dx, dy, quiet);

    const stationaries = this.connections.filter(it => pushedPieces.indexOf(it) === -1);
    pushedPieces.push(...stationaries);
    stationaries.forEach(it => it.push(dx, dy, false, pushedPieces));
  }

  /**
   *
   * @param {number} dx
   * @param {number} dy
   */
  drag(dx, dy, quiet = false) {
    if (vector.isNull(dx, dy)) return;

    if (this.horizontallyOpenMovement(dx) &amp;&amp; this.vericallyOpenMovement(dy)) {
      this.disconnect();
      this.translate(dx, dy, quiet);
    } else {
      this.push(dx, dy, quiet);
    }
  }

  drop() {
    this.puzzle.autoconnect(this);
  }

  dragAndDrop(dx, dy) {
    this.drag(dx, dy);
    this.drop();
  }

  /**
   *
   * @param {number} dy
   * @returns {boolean}
   */
  vericallyOpenMovement(dy) {
    return (dy > 0 &amp;&amp; !this.downConnection) || (dy &lt; 0 &amp;&amp; !this.upConnection) || dy == 0;
  }

  /**
   *
   * @param {number} dx
   * @returns {boolean}
   */
  horizontallyOpenMovement(dx) {
    return (dx > 0 &amp;&amp; !this.rightConnection) || (dx &lt; 0 &amp;&amp; !this.leftConnection) || dx == 0;
  }

  /**
   *
   * @param {Piece} other
   * @returns {boolean}
   */
  canConnectHorizontallyWith(other) {
    return this.horizontallyCloseTo(other) &amp;&amp; this.horizontallyMatch(other);
  }

  /**
   *
   * @param {Piece} other
   * @returns {boolean}
   */
  canConnectVerticallyWith(other) {
    return this.verticallyCloseTo(other) &amp;&amp; this.verticallyMatch(other);
  }

  /**
   *
   * @param {Piece} other
   * @returns {boolean}
   */
  verticallyCloseTo(other) {
    return this.downAnchor.closeTo(other.upAnchor, this.proximity);
  }

  /**
   *
   * @param {Piece} other
   * @returns {boolean}
   */
  horizontallyCloseTo(other) {
    return this.rightAnchor.closeTo(other.leftAnchor, this.proximity);
  }


  /**
   *
   * @param {Piece} other
   * @returns {boolean}
   */
  verticallyMatch(other) {
    return this.down.match(other.up);
  }

  /**
   *
   * @param {Piece} other
   * @returns {boolean}
   */
  horizontallyMatch(other) {
    return this.right.match(other.left);
  }

  get connected() {
    return this.upConnection || this.rightConnection || this.leftConnection || this.rightConnection;
  }

  /**
   * @return {Anchor}
   */
  get downAnchor() {
    return this.centralAnchor.translated(0, this.size);
  }

  /**
   * @return {Anchor}
   */
  get rightAnchor() {
    return this.centralAnchor.translated(this.size, 0);
  }

  /**
   * @return {Anchor}
   */
  get upAnchor() {
    return this.centralAnchor.translated(0, -this.size);
  }

  /**
   * @return {Anchor}
   */
  get leftAnchor() {
    return this.centralAnchor.translated(-this.size, 0);
  }

  /**
   * @return {number}
   */
  get size() {
    return this.puzzle.pieceSize;
  }

  /**
   * @returns {number}
   */
  get proximity() {
    return this.puzzle.proximity;
  }

}

/**
 * @typedef {(Tab|Slot|None)} Insert
 */

const Tab = {
  isSlot: () => false,
  isTab:  () => true,
  isNone:  () => false,
  match: (other) => other.isSlot(),
  toString: () => "Tab",
  complement: () => Slot,
}

const Slot = {
  isSlot: () => true,
  isTab:  () => false,
  isNone:  () => false,
  match: (other) => other.isTab(),
  toString: () => "Slot",
  complement: () => Tab,

}

const None = {
  isSlot: () => false,
  isTab:  () => false,
  isNone:  () => true,
  match: (other) => false,
  toString: () => "None",
  complement: () => None,
}

/**
 * @module Puzzle
 */
module.exports = {
  None,
  Piece,
  Puzzle,
  Slot,
  Tab
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-anchor.html">anchor</a></li><li><a href="module-DummyPainter.html">DummyPainter</a></li><li><a href="module-KonvaPainter.html">KonvaPainter</a></li><li><a href="module-Manufacturer.html">Manufacturer</a></li><li><a href="module-outline.html">outline</a></li><li><a href="module-pivot.html">pivot</a></li><li><a href="module-Puzzle.html">Puzzle</a></li><li><a href="module-PuzzleCanvas.html">PuzzleCanvas</a></li><li><a href="module-sequence.html">sequence</a></li><li><a href="module-vector.html">vector</a></li></ul><h3>Classes</h3><ul><li><a href="Anchor.html">Anchor</a></li><li><a href="InsertSequence.html">InsertSequence</a></li><li><a href="Piece.html">Piece</a></li><li><a href="Puzzle.html">Puzzle</a></li><li><a href="PuzzleCanvas.html">PuzzleCanvas</a></li></ul><h3>Global</h3><ul><li><a href="global.html#anchor">anchor</a></li><li><a href="global.html#between">between</a></li><li><a href="global.html#currentPositionDiff">currentPositionDiff</a></li><li><a href="global.html#diff">diff</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#fixed">fixed</a></li><li><a href="global.html#flipflop">flipflop</a></li><li><a href="global.html#isNull">isNull</a></li><li><a href="global.html#pieces">pieces</a></li><li><a href="global.html#pivot">pivot</a></li><li><a href="global.html#random">random</a></li><li><a href="global.html#select">select</a></li><li><a href="global.html#twoAndTwo">twoAndTwo</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Wed Jun 17 2020 12:03:37 GMT-0300 (-03)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
